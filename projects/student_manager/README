Λειτουργικά Συστήματα - 1η εργασία χειμερινού εξαμήνου 2020
Ονοματεπώνυμο: Στυλιανή Φραγκιαδάκη
ΑΜ: 1115201900205 (sdi1900205)

ΓΕΝΙΚΑ: Έχουν υλοποιηθεί όλα τα ζητούμενα της άσκησης σε C, με επαρκή σχολιασμό.

Σχετικά με το config file: 
Το αναμενόμενο format του config file είναι να περιέχει *μονο* τον αριθμό των buckets που θα χρησιμοποιηθούν στο initialization του hashtable students, χωρίς να μεσολαβεί whitespace.

Σχετικά με τις δομές δεδομένων και την υλοποίηση τους:
Στην άσκηση έχω επιλέξει να χρησιμοποιήσω generic data structures για λόγους τους οποίους θα παραθέσω.
Καταρχάς, έτσι όπως είναι δομημένη η άσκηση, θα χρειαζόταν να υλοποιήσω τουλάχιστον 3 *διαφορετικές* λίστες, κάνοντας έτσι τον κώδικα πολύ μεγάλο χωρίς να υπάρχει ιδιέταιρος λόγος.
Επίσης, έχοντας δει αυτό το μοντέλο υλοποίησης στο μάθημα Δομών Δεδομένων, θεώρησα ότι το να υλοποιήσω αυτές τις δομές με αυτό τον τρόπο, πέρα από καλή εξάσκηση, θα είναι και εύκολα reusable code.
Τέλος, θεωρώ ότι κάνει τον κώδικα πολύ πιο κατανοητό.

- Το hashtable `students` υλοποιήθηκε με seperate chaining όπου το πλήθος των buckets καθορίζεται από το πλήθος των γραμμών του input file ή από το configuration file, διαφορετικά το default πλήθος είναι 500.
Ως `value` αποθηκεύει ένα pointer σε struct student (όπου έχει γίνει malloc'd στο σωρό). Η σύμβαση που έχω είναι οτι τα studentid's είναι integers. To hashtable *δεν* είναι rehashable.

- Το ζητούμενο inverted index της εκφώνησης έχει υλοποιηθεί ως μια λίστα από λίστες. Η λίστα `years` περιέχει ListNodes όπου το value τους είναι ένας pointer σε `struct year_info`. Σε αυτό περιέχονται πληροφορίες σχετικά με αυτό το έτος (count, sum of gpas κλπ), καθώς επίσης και μια sorted λίστα `students` όπου περιέχουν δείκτες σε `struct student` - όπως ακριβώς και στο hashtable students.


- Ακόμη διατηρώ μία ακόμη λίστα `zips` που την ενημερώνω σε κάθε νέα εισαγωγή φοιτητή. Σε αυτή αποθηκεύω pointer σε `struct pair`, 
ώστε να έχω άμεση πρόσβαση στο count κάθε postal code (για το query p(ostal code)), καθώς διαφορετικά, το query αυτό θα ήταν αρκετά πιο αργό.

Για τις παραπάνω δομές υπάρχουν οι κατάλληλες συναρτήσεις compare & destroy που περνιούνται ως παράμετροι. (βλ. compare_funcs.c)
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 

Η αρχικοποίηση των δομών που χρησιμοποιουνται στην εργασία, καθώς και οι συναρτήσεις εισαγωγής που επενεργούν σε αυτές βρίσκονται στο αρχείο init.c 

Στο αρχείο parse.c, μεταξύ άλλων, αναγνωρίζεται η εντολή που δίνεται από τον χρήστη και καλείται το κατάλληλο query με όρισμα ένα πίνακα με τις παραμέτρους που έχουν διαχωριστεί με την strtok().
Σε κάθε εντολή γίνεται έλεγχος στον αριθμό των arguments της, ωστε να είμαστε σίγουροι ότι η εκτέλεση της θα έχει το επιθυμητό αποτέλεσμα. Διαφορετικά, εμφανίζεται μήνυμα με το expected format.


Σχετικά με τις ζητούμενες λειτουργίες (queries):

insert --> Αν ο student δεν υπαρχει στον πίνακα κατακερματισμού, δεσμευεται δυναμικά και εισάγεται σε αυτόν. Ύστερα ψάχνουμε στη λίστα `years` εαν υπάρχει κόμβος για το έτος του φοιτητή που μόλις εισάγαμε.
Αν δεν υπάρχει τότε δημιουργούμε έναν, αλλιώς ενημερωνουμε τις πληροφορίες του έτους (count κλπ). Στη λίστα students του year_info, εισάγουμε τον φοιτητή στη σωστή του θέση (ταξινόμηση ως προς τον gpa).
Τέλος, ψάχνουμε στη λίστα `zips` εαν υπαρχει ο ΤΚ του φοιτητή. Αν ναι, αυξάνουμε το count του, διαφορετικά δημιουργούμε έναν καινούριο κόμο με τον ΤΚ του και count = 1.

look-up --> Κάνουμε ένα απλό search στο hashtable students.

delete --> Αφαιρούμε τον student από τη λίστα του έτους του και κάνουμε update το year_info του. Ύστερα μειώνουμε κατα ένα το count του ΤΚ του και τελικά τον αφαιροούμε από το hashtable, αποδεσμεύοντας δυναμικά τη μνήμη που είχε προηγουμένως δεσμευτεί.

number --> Διατρέχουμε τη λίστα `years` και για κάθε κόμβο της εμφανίζουμε το count (δηλ. ο αριθμός των φοιτητών αυτού του έτους που παραμένουν εγγεγραμμένοι).

top --> Στη λίστα students του `year` τυπώνουμε τους `num` πρώτους φοιτητές. Αν οι επόμενοι φοιτητές από τον `num` φοιτητή έχουν την ίδια βαθμολογία, τυπώνονται και αυτοί, μέχρι να βρούμε τον φοιτητή με τον 
αμέσως επόμενο βαθμό, όπου και σταματάμε.
Για παράδειγμα, μια εκτέλεση αν έχουμε 102 φοιτητές όπου οι πρώτοι 100 ισοβαθμούν, και οι υπολοιποι 2 έχουν μικροτερο gpa θα είναι:
  t 2020 1 --> όλοι οι 100 πρώτοι
  t 2020 2 --> όλοι οι 100 πρώτοι
  ...
  ...
  t 2020 100 --> όλοι οι 100 πρώτοι
  t 2020 101 --> όλοι οι 100 πρώτοι *και* ο 101ος

average --> Στη λίστα students του `year` τυπώνουμε το πηλικο των gpa_sum & count, καθώς είναι πληροφορίες που είναι άμεσα διαθέσιμες στο year_info.

minimum --> Ενδέχεται να υπάρχει παραπάνω από ενας φοιτητής ο οποίος έχει τον minimum gpa στο έτος του. Επομένως δεν μας αρκεί να επιστρέψουμε τον τελευταίο φοιτητή της λίστας. 
Άρα αυτό που κάνουμε είναι να διατρέξουμε τη λιστα (με τους φοιτητές του ίδιου έτους) και να τυπώσουμε τους φοιτητές που ο gpa τους είναι ίσος με τον gpa του τελευταίου φοιτητή της λίστας.

count --> Διατρέχουμε τη λίστα `years` και τυπώνουμε το count σε κάθε κόμβο της.

postal code --> Μεταφέρουμε όλα τα στοιχεία της λίστας `zips` σε ένα δυναμικά δεσμευμένο πίνακα ώστε να μπορούμε να τον ταξινομήσουμε γρήγορα με την qsort() 
(descending order ως προς το count των ΤΚ).
Ύστερα για κάθε *διαφορετικό* count που βρίσκουμε αυξάνουμε το `curr_rank` μέχρι να φτάσουμε στο επιθυμητό `rank`. 
Από εκέι και πέρα τυπώνουμε όλους τους ΤΚ που εχουν το ίδιο count με τον rank-th ΤΚ.

exit --> Αρχικά αποδεσμευεται ο inverted index, ύστερα η λίστα `zips` και τέλος το hashtable students, και η εφαρμογή τερματίζει επιτυχώς :D 

Σε όλα τα παραπάνω εμφανίζονται μηνυματα σε περίπτωση μη αναμενόμενης χρήσης.
Ακόμη, έχει γίνει έλεγχος με valgrind και δεν υπάρχουν memory leaks.


Καλή διόρθωση! :D



